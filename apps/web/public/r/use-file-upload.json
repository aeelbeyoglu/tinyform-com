{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-file-upload",
  "type": "registry:hook",
  "title": "file upload hook",
  "description": "state management hook for file upload component",
  "files": [
    {
      "path": "src/form-builder/hooks/use-file-upload.tsx",
      "content": "\"use client\";\r\n\r\nimport type React from \"react\";\r\n\r\nimport {\r\n  useCallback,\r\n  useRef,\r\n  useState,\r\n  type ChangeEvent,\r\n  type DragEvent,\r\n  type InputHTMLAttributes,\r\n} from \"react\";\r\n\r\nexport type FileMetadata = {\r\n  name: string;\r\n  size: number;\r\n  type: string;\r\n  url: string;\r\n  id: string;\r\n};\r\n\r\nexport type FileWithPreview = {\r\n  file: File | FileMetadata;\r\n  id: string;\r\n  preview?: string;\r\n};\r\n\r\nexport type FileUploadOptions = {\r\n  maxFiles?: number; // Only used when multiple is true, defaults to Infinity\r\n  maxSize?: number; // in bytes\r\n  accept?: string;\r\n  multiple?: boolean; // Defaults to false\r\n  initialFiles?: FileMetadata[];\r\n  onFilesChange?: (files: FileWithPreview[]) => void; // Callback when files change\r\n  onFilesAdded?: (addedFiles: FileWithPreview[]) => void; // Callback when new files are added\r\n};\r\n\r\nexport type FileUploadState = {\r\n  files: FileWithPreview[];\r\n  isDragging: boolean;\r\n  errors: string[];\r\n};\r\n\r\nexport type FileUploadActions = {\r\n  addFiles: (files: FileList | File[]) => void;\r\n  removeFile: (id: string) => void;\r\n  clearFiles: () => void;\r\n  clearErrors: () => void;\r\n  handleDragEnter: (e: DragEvent<HTMLElement>) => void;\r\n  handleDragLeave: (e: DragEvent<HTMLElement>) => void;\r\n  handleDragOver: (e: DragEvent<HTMLElement>) => void;\r\n  handleDrop: (e: DragEvent<HTMLElement>) => void;\r\n  handleFileChange: (e: ChangeEvent<HTMLInputElement>) => void;\r\n  openFileDialog: () => void;\r\n  getInputProps: (\r\n    props?: InputHTMLAttributes<HTMLInputElement>\r\n  ) => InputHTMLAttributes<HTMLInputElement> & {\r\n    ref: React.Ref<HTMLInputElement>;\r\n  };\r\n};\r\n\r\nexport const useFileUpload = (\r\n  options: FileUploadOptions = {}\r\n): [FileUploadState, FileUploadActions] => {\r\n  const {\r\n    maxFiles = Infinity,\r\n    maxSize = Infinity,\r\n    accept = \"*\",\r\n    multiple = false,\r\n    initialFiles = [],\r\n    onFilesChange,\r\n    onFilesAdded,\r\n  } = options;\r\n\r\n  const [state, setState] = useState<FileUploadState>({\r\n    files: initialFiles.map((file) => ({\r\n      file,\r\n      id: file.id,\r\n      preview: file.url,\r\n    })),\r\n    isDragging: false,\r\n    errors: [],\r\n  });\r\n\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const createPreview = useCallback(\r\n    (file: File | FileMetadata): string | undefined => {\r\n      if (file instanceof File) {\r\n        return URL.createObjectURL(file);\r\n      }\r\n      return file.url;\r\n    },\r\n    []\r\n  );\r\n\r\n  const generateUniqueId = useCallback((file: File | FileMetadata): string => {\r\n    if (file instanceof File) {\r\n      return `${file.name}-${crypto.randomUUID()}`;\r\n    }\r\n    return file.id;\r\n  }, []);\r\n\r\n  const clearFiles = useCallback(() => {\r\n    setState((prev) => {\r\n      // Clean up object URLs\r\n      prev.files.forEach((file) => {\r\n        if (\r\n          file.preview &&\r\n          file.file instanceof File &&\r\n          file.file.type.startsWith(\"image/\")\r\n        ) {\r\n          URL.revokeObjectURL(file.preview);\r\n        }\r\n      });\r\n\r\n      if (inputRef.current) {\r\n        inputRef.current.value = \"\";\r\n      }\r\n\r\n      const newState = {\r\n        ...prev,\r\n        files: [],\r\n        errors: [],\r\n      };\r\n\r\n      onFilesChange?.(newState.files);\r\n      return newState;\r\n    });\r\n  }, [onFilesChange]);\r\n\r\n  const addFiles = useCallback(\r\n    (newFiles: FileList | File[]) => {\r\n      if (!newFiles || newFiles.length === 0) return;\r\n\r\n      const newFilesArray = Array.from(newFiles);\r\n      const errors: string[] = [];\r\n\r\n      // Clear existing errors when new files are uploaded\r\n      setState((prev) => ({ ...prev, errors: [] }));\r\n\r\n      // In single file mode, clear existing files first\r\n      if (!multiple) {\r\n        clearFiles();\r\n      }\r\n\r\n      // Check if adding these files would exceed maxFiles (only in multiple mode)\r\n      if (\r\n        multiple &&\r\n        maxFiles !== Infinity &&\r\n        state.files.length + newFilesArray.length > maxFiles\r\n      ) {\r\n        errors.push(`You can only upload a maximum of ${maxFiles} files.`);\r\n        setState((prev) => ({ ...prev, errors }));\r\n        return;\r\n      }\r\n\r\n      const validFiles: FileWithPreview[] = [];\r\n\r\n      newFilesArray.forEach((file) => {\r\n        // Only check for duplicates if multiple files are allowed\r\n        if (multiple) {\r\n          const isDuplicate = state.files.some(\r\n            (existingFile) =>\r\n              existingFile.file.name === file.name &&\r\n              existingFile.file.size === file.size\r\n          );\r\n\r\n          // Skip duplicate files silently\r\n          if (isDuplicate) {\r\n            return;\r\n          }\r\n        }\r\n\r\n        validFiles.push({\r\n          file,\r\n          id: generateUniqueId(file),\r\n          preview: createPreview(file),\r\n        });\r\n      });\r\n\r\n      // Only update state if we have valid files to add\r\n      if (validFiles.length > 0) {\r\n        // Call the onFilesAdded callback with the newly added valid files\r\n        onFilesAdded?.(validFiles);\r\n\r\n        setState((prev) => {\r\n          const newFiles = !multiple\r\n            ? validFiles\r\n            : [...prev.files, ...validFiles];\r\n          onFilesChange?.(newFiles);\r\n          return {\r\n            ...prev,\r\n            files: newFiles,\r\n            errors,\r\n          };\r\n        });\r\n      } else if (errors.length > 0) {\r\n        setState((prev) => ({\r\n          ...prev,\r\n          errors,\r\n        }));\r\n      }\r\n\r\n      // Reset input value after handling files\r\n      if (inputRef.current) {\r\n        inputRef.current.value = \"\";\r\n      }\r\n    },\r\n    [\r\n      state.files,\r\n      maxFiles,\r\n      multiple,\r\n      maxSize,\r\n      // validateFile,\r\n      createPreview,\r\n      generateUniqueId,\r\n      clearFiles,\r\n      onFilesChange,\r\n      onFilesAdded,\r\n    ]\r\n  );\r\n\r\n  const removeFile = useCallback(\r\n    (id: string) => {\r\n      setState((prev) => {\r\n        const fileToRemove = prev.files.find((file) => file.id === id);\r\n        if (\r\n          fileToRemove &&\r\n          fileToRemove.preview &&\r\n          fileToRemove.file instanceof File &&\r\n          fileToRemove.file.type.startsWith(\"image/\")\r\n        ) {\r\n          URL.revokeObjectURL(fileToRemove.preview);\r\n        }\r\n\r\n        const newFiles = prev.files.filter((file) => file.id !== id);\r\n        onFilesChange?.(newFiles);\r\n\r\n        return {\r\n          ...prev,\r\n          files: newFiles,\r\n          errors: [],\r\n        };\r\n      });\r\n    },\r\n    [onFilesChange]\r\n  );\r\n\r\n  const clearErrors = useCallback(() => {\r\n    setState((prev) => ({\r\n      ...prev,\r\n      errors: [],\r\n    }));\r\n  }, []);\r\n\r\n  const handleDragEnter = useCallback((e: DragEvent<HTMLElement>) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    setState((prev) => ({ ...prev, isDragging: true }));\r\n  }, []);\r\n\r\n  const handleDragLeave = useCallback((e: DragEvent<HTMLElement>) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n\r\n    if (e.currentTarget.contains(e.relatedTarget as Node)) {\r\n      return;\r\n    }\r\n\r\n    setState((prev) => ({ ...prev, isDragging: false }));\r\n  }, []);\r\n\r\n  const handleDragOver = useCallback((e: DragEvent<HTMLElement>) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n  }, []);\r\n\r\n  const handleDrop = useCallback(\r\n    (e: DragEvent<HTMLElement>) => {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n      setState((prev) => ({ ...prev, isDragging: false }));\r\n\r\n      // Don't process files if the input is disabled\r\n      if (inputRef.current?.disabled) {\r\n        return;\r\n      }\r\n\r\n      if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\r\n        // In single file mode, only use the first file\r\n        if (!multiple) {\r\n          const file = e.dataTransfer.files[0];\r\n          addFiles([file]);\r\n        } else {\r\n          addFiles(e.dataTransfer.files);\r\n        }\r\n      }\r\n    },\r\n    [addFiles, multiple]\r\n  );\r\n\r\n  const handleFileChange = useCallback(\r\n    (e: ChangeEvent<HTMLInputElement>) => {\r\n      if (e.target.files && e.target.files.length > 0) {\r\n        addFiles(e.target.files);\r\n      }\r\n    },\r\n    [addFiles]\r\n  );\r\n\r\n  const openFileDialog = useCallback(() => {\r\n    if (inputRef.current) {\r\n      inputRef.current.click();\r\n    }\r\n  }, []);\r\n\r\n  const getInputProps = useCallback(\r\n    (props: InputHTMLAttributes<HTMLInputElement> = {}) => {\r\n      return {\r\n        ...props,\r\n        type: \"file\" as const,\r\n        onChange: handleFileChange,\r\n        accept: props.accept || accept,\r\n        multiple: props.multiple !== undefined ? props.multiple : multiple,\r\n        ref: inputRef,\r\n      };\r\n    },\r\n    [accept, multiple, handleFileChange]\r\n  );\r\n\r\n  return [\r\n    state,\r\n    {\r\n      addFiles,\r\n      removeFile,\r\n      clearFiles,\r\n      clearErrors,\r\n      handleDragEnter,\r\n      handleDragLeave,\r\n      handleDragOver,\r\n      handleDrop,\r\n      handleFileChange,\r\n      openFileDialog,\r\n      getInputProps,\r\n    },\r\n  ];\r\n};\r\n\r\n// Helper function to format bytes to human-readable format\r\nexport const formatBytes = (bytes: number, decimals = 2): string => {\r\n  if (bytes === 0) return \"0 Bytes\";\r\n\r\n  const k = 1024;\r\n  const dm = decimals < 0 ? 0 : decimals;\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\r\n\r\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n\r\n  return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + sizes[i];\r\n};\r\n",
      "type": "registry:hook"
    }
  ]
}